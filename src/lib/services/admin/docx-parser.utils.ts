import type { Question } from './exam.service';

export interface DocxFormatConfig {
	questionPattern: RegExp;
	answerPattern: RegExp;
	optionPatterns: RegExp[];
}

export const defaultDocxFormat: DocxFormatConfig = {
	// Strictly requires brackets: [SOAL] or [SOAL 1]
	questionPattern: /^\[SOAL(?:\s+\d+)?\]/i,
	// Strictly requires brackets: [JAWABAN] A
	answerPattern: /^\[JAWABAN\]\s*([A-E])/i,
	// Strictly requires brackets: [A], [B], [C], [D], [E]
	optionPatterns: [/^\[A\]/i, /^\[B\]/i, /^\[C\]/i, /^\[D\]/i, /^\[E\]/i]
};

type ParseState = 'IDLE' | 'QUESTION' | 'OPTION' | 'ANSWER';

export class DocxParserUtils {
	/**
	 * Parse HTML string generated by mammoth.js into an array of Questions
	 * based on the provided format configuration.
	 */
	public static parseHtmlToQuestions(
		htmlString: string,
		config: DocxFormatConfig = defaultDocxFormat
	): Question[] {
		const questions: Question[] = [];

		// Create an invisible detached DOM container to safely traverse mammoth's output
		const doc = document.createElement('div');
		doc.innerHTML = htmlString;

		let currentQuestion: Partial<Question> | null = null;
		let currentState: ParseState = 'IDLE';
		let currentOptionIndex = -1;
		let currentBuffer = '';

		/**
		 * Flushes the accumulated buffer into the appropriate field
		 * of the current question (question_text or an option).
		 */
		const flushBuffer = () => {
			if (!currentQuestion) return;
			const cleanHtml = currentBuffer.trim();
			if (!cleanHtml) {
				currentBuffer = '';
				return;
			}

			if (currentState === 'QUESTION') {
				currentQuestion.question_text = (currentQuestion.question_text || '') + cleanHtml;
			} else if (currentState === 'OPTION' && currentOptionIndex >= 0) {
				if (!currentQuestion.options) {
					currentQuestion.options = ['', '', '', '', ''];
				}
				currentQuestion.options[currentOptionIndex] =
					(currentQuestion.options[currentOptionIndex] || '') + cleanHtml;
			}
			// In 'ANSWER' or 'IDLE' state, we discard the buffer safely
			currentBuffer = '';
		};

		/**
		 * Validates and pushes the current question into the questions array,
		 * then resets all state for the next question.
		 */
		const pushQuestionIfValid = () => {
			// Flush any remaining buffered content before saving
			flushBuffer();

			if (
				currentQuestion &&
				currentQuestion.question_text &&
				currentQuestion.question_text.trim() !== '' &&
				currentQuestion.options &&
				currentQuestion.options.some((opt: string) => opt.trim() !== '')
			) {
				const orderNum = questions.length + 1;
				const formattedQuestion: Question = {
					question_text: currentQuestion.question_text.trim(),
					question_type: 'MULTIPLE_CHOICE',
					options: currentQuestion.options.map((o: string) => o.trim()),
					correct_option: currentQuestion.correct_option ?? '0',
					order_num: orderNum,
					score_value: 1
				};
				questions.push(formattedQuestion);
			}

			// Reset state
			currentQuestion = null;
			currentState = 'IDLE';
			currentOptionIndex = -1;
			currentBuffer = '';
		};

		/**
		 * Strips the matched pattern token from a node's innerHTML and returns
		 * the cleaned outer HTML, preserving any inner formatting tags.
		 */
		const getCleanedNodeHtml = (node: Node, pattern: RegExp): string => {
			if (node instanceof HTMLElement) {
				const clone = node.cloneNode(true) as HTMLElement;
				// Walk text nodes inside the clone and remove only the first match
				const walker = document.createTreeWalker(clone, NodeFilter.SHOW_TEXT);
				let textNode: Text | null = walker.nextNode() as Text | null;
				while (textNode) {
					if (pattern.test(textNode.textContent || '')) {
						textNode.textContent = (textNode.textContent || '').replace(pattern, '').trim();
						break;
					}
					textNode = walker.nextNode() as Text | null;
				}
				return clone.outerHTML;
			}
			const cleaned = (node.textContent || '').replace(pattern, '').trim();
			return cleaned ? `<p>${cleaned}</p>` : '';
		};

		// Walk through all top-level child nodes generated by Mammoth
		for (let i = 0; i < doc.childNodes.length; i++) {
			const node = doc.childNodes[i];
			const textContent = node.textContent?.trim() || '';

			// Check if this node contains embedded images (e.g. <p><img src="..." /></p>)
			const hasImages = node instanceof HTMLElement && node.querySelector('img') !== null;

			// Skip completely empty nodes — but keep nodes that contain images
			if (!textContent && !hasImages) continue;

			// ── 1. New QUESTION marker ─────────────────────────────────────────
			if (textContent && config.questionPattern.test(textContent)) {
				// Save the previous question (if any) before starting a new one
				pushQuestionIfValid();

				currentQuestion = {
					question_text: '',
					options: ['', '', '', '', ''],
					correct_option: '0'
				};
				currentState = 'QUESTION';

				// The question label ([SOAL N]) is on its own line in mammoth output,
				// so there is usually no trailing text here — but handle it just in case.
				const cleanedHtml = getCleanedNodeHtml(node, config.questionPattern);
				if (cleanedHtml && cleanedHtml.replace(/<[^>]+>/g, '').trim()) {
					currentBuffer += cleanedHtml;
				}
				continue;
			}

			// ── 2. ANSWER KEY marker ──────────────────────────────────────────
			const answerMatch = textContent ? textContent.match(config.answerPattern) : null;
			if (answerMatch && currentQuestion) {
				flushBuffer(); // Flush the last option before recording the answer
				currentState = 'ANSWER';
				const answerLetter = answerMatch[1].toUpperCase();
				const answerIndex = answerLetter.charCodeAt(0) - 65; // 'A' = 0 … 'E' = 4
				if (answerIndex >= 0 && answerIndex <= 4) {
					currentQuestion.correct_option = String(answerIndex);
				}
				continue;
			}

			// ── 3. OPTION marker ──────────────────────────────────────────────
			let matchedOption = false;
			if (textContent) {
				for (let optIdx = 0; optIdx < config.optionPatterns.length; optIdx++) {
					if (config.optionPatterns[optIdx].test(textContent)) {
						flushBuffer(); // Flush the previous option/question text
						currentState = 'OPTION';
						currentOptionIndex = optIdx;

						const cleanedHtml = getCleanedNodeHtml(node, config.optionPatterns[optIdx]);
						if (cleanedHtml && cleanedHtml.replace(/<[^>]+>/g, '').trim()) {
							currentBuffer += cleanedHtml;
						}
						matchedOption = true;
						break;
					}
				}
			}
			if (matchedOption) continue;

			// ── 4. Continuation content ───────────────────────────────────────
			// Append to buffer when inside a question or option block.
			// This now also captures image-only nodes (e.g. <p><img .../></p>).
			if (currentState === 'QUESTION' || currentState === 'OPTION') {
				if (node instanceof HTMLElement) {
					currentBuffer += node.outerHTML;
				} else if (node.nodeType === Node.TEXT_NODE && textContent) {
					currentBuffer += `<p>${textContent}</p>`;
				}
			}
		}

		// Push the final question that has no trailing [SOAL] to trigger it
		pushQuestionIfValid();

		return questions;
	}
}
