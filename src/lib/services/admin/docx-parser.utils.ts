import type { Question } from './exam.service';

export interface DocxFormatConfig {
	questionPattern: RegExp;
	answerPattern: RegExp;
	optionPatterns: RegExp[];
}

export const defaultDocxFormat: DocxFormatConfig = {
	// Matches "[SOAL]" or "SOAL:" at the start of a block
	questionPattern: /^\[?SOAL(?:\s+\d+)?\]?:?/i,
	// Matches "[JAWABAN] A" or "JAWABAN: B"
	answerPattern: /^\[?JAWABAN\]?:?\s*([A-E])/i,
	// Matches "[A]", "A.", "(A)", etc.
	optionPatterns: [
		/^\[?A\]?\.?\)?:?/i,
		/^\[?B\]?\.?\)?:?/i,
		/^\[?C\]?\.?\)?:?/i,
		/^\[?D\]?\.?\)?:?/i,
		/^\[?E\]?\.?\)?:?/i
	]
};

type ParseState = 'IDLE' | 'QUESTION' | 'OPTION' | 'ANSWER';

export class DocxParserUtils {
	/**
	 * Parse HTML string generated by mammoth.js into an array of Questions based on the provided format configure.
	 */
	public static parseHtmlToQuestions(
		htmlString: string,
		config: DocxFormatConfig = defaultDocxFormat
	): Question[] {
		const questions: Question[] = [];

		// Create an invisible detached DOM container to safely traverse mammoth's output
		const doc = document.createElement('div');
		doc.innerHTML = htmlString;

		let currentQuestion: Partial<Question> | null = null;
		let currentState: ParseState = 'IDLE';
		let currentOptionIndex = -1;
		let currentBuffer = '';

		const flushBuffer = () => {
			if (!currentQuestion) return;
			const cleanHtml = currentBuffer.trim();
			if (!cleanHtml) return;

			if (currentState === 'QUESTION') {
				currentQuestion.question_text = (currentQuestion.question_text || '') + cleanHtml;
			} else if (currentState === 'OPTION' && currentOptionIndex >= 0) {
				if (!currentQuestion.options) {
					currentQuestion.options = ['', '', '', '', ''];
				}
				currentQuestion.options[currentOptionIndex] =
					(currentQuestion.options[currentOptionIndex] || '') + cleanHtml;
			}
			currentBuffer = '';
		};

		const pushQuestionInfo = () => {
			flushBuffer();
			if (
				currentQuestion &&
				currentQuestion.question_text &&
				currentQuestion.options &&
				currentQuestion.options.some((opt: string) => opt.trim() !== '')
			) {
				// Determine a valid order_num and correct_option fallback
				const orderNum = questions.length + 1;
				const formattedQuestion: Question = {
					question_text: currentQuestion.question_text.trim(),
					question_type: 'MULTIPLE_CHOICE',
					options: currentQuestion.options,
					correct_option: currentQuestion.correct_option || '0',
					order_num: orderNum,
					score_value: 1 // Default score
				};
				questions.push(formattedQuestion);
			}
			currentQuestion = null;
			currentState = 'IDLE';
			currentOptionIndex = -1;
			currentBuffer = '';
		};

		// Walk through all top-level child nodes generated by Mammoth
		for (let i = 0; i < doc.childNodes.length; i++) {
			const node = doc.childNodes[i];
			const textContent = node.textContent?.trim() || '';

			// 1. Check if this node marks the START of a new QUESTION
			if (config.questionPattern.test(textContent)) {
				pushQuestionInfo(); // Save previous question if exists

				currentQuestion = {
					question_text: '',
					options: ['', '', '', '', ''],
					correct_option: '0'
				};
				currentState = 'QUESTION';
				// Remove the actual tag like "[SOAL]" from the text if it's on the same line
				const cleanContent = textContent.replace(config.questionPattern, '').trim();

				if (cleanContent) {
					// Try to preserve internal HTML formatting for inline text
					if (node instanceof HTMLElement) {
						const clone = node.cloneNode(true) as HTMLElement;
						// Simplistic removal of the token text. A more robust way would be to walk the text nodes
						// but since mammoth outputs block elements (like <p>), we can just replace text.
						clone.innerHTML = clone.innerHTML.replace(config.questionPattern, '').trim();
						currentBuffer += clone.outerHTML;
					} else {
						currentBuffer += `<p>${cleanContent}</p>`;
					}
				}
				continue;
			}

			// 2. Check if this node marks an ANSWER KEY
			const answerMatch = textContent.match(config.answerPattern);
			if (answerMatch && currentQuestion) {
				flushBuffer();
				currentState = 'ANSWER';
				const answerLetter = answerMatch[1].toUpperCase();
				// Convert letters A, B, C... to indices 0, 1, 2...
				const answerIndex = answerLetter.charCodeAt(0) - 65;
				if (answerIndex >= 0 && answerIndex <= 4) {
					currentQuestion.correct_option = String(answerIndex);
				}
				continue;
			}

			// 3. Check if this node marks an OPTION block
			let matchedOption = false;
			for (let optIdx = 0; optIdx < config.optionPatterns.length; optIdx++) {
				if (config.optionPatterns[optIdx].test(textContent)) {
					flushBuffer();
					currentState = 'OPTION';
					currentOptionIndex = optIdx;

					const cleanContent = textContent.replace(config.optionPatterns[optIdx], '').trim();
					if (cleanContent) {
						if (node instanceof HTMLElement) {
							const clone = node.cloneNode(true) as HTMLElement;
							clone.innerHTML = clone.innerHTML.replace(config.optionPatterns[optIdx], '').trim();
							currentBuffer += clone.outerHTML;
						} else {
							currentBuffer += `<p>${cleanContent}</p>`;
						}
					}
					matchedOption = true;
					break;
				}
			}
			if (matchedOption) continue;

			// 4. Default handler: Append node to whatever buffer is currently active
			if (currentState !== 'IDLE' && currentState !== 'ANSWER') {
				if (node instanceof HTMLElement) {
					currentBuffer += node.outerHTML;
				} else if (node.nodeType === Node.TEXT_NODE && textContent) {
					currentBuffer += `<p>${textContent}</p>`;
				}
			}
		}

		// Push the final dangling question
		pushQuestionInfo();

		return questions;
	}
}
